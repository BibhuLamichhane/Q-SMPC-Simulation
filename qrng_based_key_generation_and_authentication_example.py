# -*- coding: utf-8 -*-
"""QRNG based key generation and authentication example.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tm5jNzxnnDM2RtvBgZB_K_uZK0F2ot0j
"""

import hashlib
import hmac
import requests
from collections import Counter
from scipy.stats import entropy

def fetch_qrng_bits(length=1024):
    """Fetch real quantum random bits from ANU QRNG API."""
    num_bytes = length // 8
    url = f"https://qrng.anu.edu.au/API/jsonI.php?length={num_bytes}&type=uint8"
    response = requests.get(url)

    try:
        data = response.json()
    except Exception:
        print("Error: QRNG API returned invalid response.")
        return None

    if not data.get("success"):
        print("Error: QRNG API did not return success.")
        return None

    bits = ''.join(f'{byte:08b}' for byte in data['data'])
    return bits[:length]

def bits_to_bytes(bitstring):
    """Convert binary string to bytes."""
    byte_chunks = [bitstring[i:i+8] for i in range(0, len(bitstring), 8)]
    return bytes([int(b, 2) for b in byte_chunks if len(b) == 8])

def derive_key(qrng_bits):
    """Create a secret key from quantum randomness using SHA-256."""
    qrng_bytes = bits_to_bytes(qrng_bits)
    return hashlib.sha256(qrng_bytes).digest()

def authenticate(shared_key, challenge):
    """Generate a secure HMAC response to a challenge using the shared key."""
    return hmac.new(shared_key, challenge.encode(), hashlib.sha256).hexdigest()

def calculate_bit_entropy(bitstring):
    """Measure how unpredictable the binary string is (0 to 1)."""
    counts = Counter(bitstring)
    probabilities = [count / len(bitstring) for count in counts.values()]
    return entropy(probabilities, base=2)

# Get quantum random bits
qrng_bits = fetch_qrng_bits(1024)
if not qrng_bits:
    raise RuntimeError("Failed to get quantum bits.")

# Create a secret vault code from these bits
secret_key = derive_key(qrng_bits)

# Login challenge name
challenge = "LOGIN-REQUEST-SIMULATION"


# Entropy analysis
bit_entropy = calculate_bit_entropy(qrng_bits)

expected_response = authenticate(secret_key, challenge)
expected_response

# Simulation
print("\nQuantum Login Validation Simulation\n")

print("This is a simulated login system powered by quantum randomness.")
print("To gain access, you’ll need to provide the correct response to a challenge.")
print("In a real-world scenario, this response would be generated using your quantum-derived secret key and the exact challenge string.\n")
print("For testing purposes, the correct response is the output from the previous cell.\n")

print(f"Challenge issued by the system: {challenge}")
user_input = input("Enter your response to the challenge: ").strip()

# Check the response
if user_input == expected_response:
    print("\nACCESS GRANTED!")
    print("Your response matches the quantum-authenticated key.\n")
else:
    print("\nACCESS DENIED.")
    print("The response did not match the expected value. Authentication failed.\n")

# Randomness evaluation
print("Let’s now evaluate the strength of the secret key you used.")
print(f"Entropy score: {bit_entropy:.6f} bits per bit (1.0 = perfect unpredictability)")
if bit_entropy >= 0.99:
    print("Excellent! The randomness is near-perfect — ideal for secure systems.")
elif bit_entropy >= 0.95:
    print("Very strong. This level of unpredictability is sufficient for most secure applications.")
else:
    print("Warning: The randomness is weak. A skilled attacker might eventually guess your key.")

